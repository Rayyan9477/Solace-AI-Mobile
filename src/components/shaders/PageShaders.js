/**
 * Page Shaders and Background Effects
 * Advanced visual effects for mental health app using React Native
 * Includes therapeutic gradients, glassmorphism, and particle effects
 */

import React, { useEffect, useRef, useState } from 'react';
import {
  View,
  StyleSheet,
  Animated,
  Dimensions,
  Platform,
  Easing,
} from 'react-native';
import LinearGradient from 'expo-linear-gradient';
import { BlurView } from '@react-native-community/blur';
import { useTheme } from '../../shared/theme/ThemeContext';
import { FreudColors } from '../../shared/theme/FreudDesignSystem';

const { width: screenWidth, height: screenHeight } = Dimensions.get('window');

// Therapeutic Gradient Backgrounds
export const TherapeuticGradient = ({
  type = 'calming',
  children,
  style = {},
  animated = true,
  animationDuration = 10000,
}) => {
  const animationValue = useRef(new Animated.Value(0)).current;

  useEffect(() => {
    if (animated) {
      Animated.loop(
        Animated.timing(animationValue, {
          toValue: 1,
          duration: animationDuration,
          easing: Easing.inOut(Easing.sin),
          useNativeDriver: false,
        })
      ).start();
    }
  }, [animated]);

  const getGradientColors = (gradientType) => {
    const time = new Date().getHours();
    const isEvening = time >= 18 || time <= 6;
    const isMorning = time >= 6 && time <= 12;
    const isAfternoon = time > 12 && time < 18;

    switch (gradientType) {
      case 'calming':
        if (isEvening) {
          return [\n            FreudColors.kindPurple[30],\n            FreudColors.serenityGreen[20],\n            FreudColors.optimisticGray[10],\n          ];\n        } else if (isMorning) {\n          return [\n            FreudColors.zenYellow[20],\n            FreudColors.serenityGreen[30],\n            FreudColors.optimisticGray[10],\n          ];\n        }\n        return [\n          FreudColors.serenityGreen[30],\n          FreudColors.optimisticGray[20],\n          FreudColors.mindfulBrown[10],\n        ];\n\n      case 'nurturing':\n        return [\n          FreudColors.serenityGreen[40],\n          FreudColors.serenityGreen[20],\n          '#FFFFFF',\n        ];\n\n      case 'peaceful':\n        return [\n          FreudColors.optimisticGray[30],\n          FreudColors.optimisticGray[10],\n          '#FFFFFF',\n        ];\n\n      case 'grounding':\n        return [\n          FreudColors.mindfulBrown[40],\n          FreudColors.mindfulBrown[20],\n          FreudColors.mindfulBrown[10],\n        ];\n\n      case 'energizing':\n        return [\n          FreudColors.empathyOrange[40],\n          FreudColors.zenYellow[30],\n          FreudColors.zenYellow[10],\n        ];\n\n      case 'therapeutic':\n        return [\n          FreudColors.kindPurple[40],\n          FreudColors.serenityGreen[40],\n          FreudColors.optimisticGray[10],\n        ];\n\n      case 'sunset':\n        return [\n          FreudColors.empathyOrange[50],\n          FreudColors.zenYellow[40],\n          FreudColors.kindPurple[30],\n          FreudColors.serenityGreen[20],\n        ];\n\n      case 'ocean':\n        return [\n          FreudColors.serenityGreen[60],\n          FreudColors.optimisticGray[40],\n          FreudColors.serenityGreen[30],\n          '#FFFFFF',\n        ];\n\n      default:\n        return [\n          FreudColors.serenityGreen[30],\n          FreudColors.optimisticGray[20],\n          '#FFFFFF',\n        ];\n    }\n  };\n\n  const colors = getGradientColors(type);\n\n  if (animated) {\n    const interpolatedColors = colors.map((color, index) => {\n      return animationValue.interpolate({\n        inputRange: [0, 0.5, 1],\n        outputRange: [color, colors[(index + 1) % colors.length], color],\n        extrapolate: 'clamp',\n      });\n    });\n\n    return (\n      <Animated.View style={[styles.gradientContainer, style]}>\n        <LinearGradient\n          colors={colors}\n          locations={[0, 0.5, 1]}\n          start={[0, 0]}\n          end={[1, 1]}\n          style={styles.gradient}\n        />\n        {children}\n      </Animated.View>\n    );\n  }\n\n  return (\n    <View style={[styles.gradientContainer, style]}>\n      <LinearGradient\n        colors={colors}\n        start={[0, 0]}\n        end={[1, 1]}\n        style={styles.gradient}\n      />\n      {children}\n    </View>\n  );\n};\n\n// Glassmorphism Container\nexport const GlassmorphismContainer = ({\n  children,\n  blurIntensity = 20,\n  backgroundColor = 'rgba(255, 255, 255, 0.25)',\n  borderColor = 'rgba(255, 255, 255, 0.3)',\n  borderWidth = 1,\n  borderRadius = 16,\n  style = {},\n}) => {\n  const { isDarkMode } = useTheme();\n\n  const glassStyle = {\n    backgroundColor: isDarkMode \n      ? 'rgba(0, 0, 0, 0.25)' \n      : backgroundColor,\n    borderColor: isDarkMode \n      ? 'rgba(255, 255, 255, 0.1)' \n      : borderColor,\n    borderWidth,\n    borderRadius,\n    overflow: 'hidden',\n  };\n\n  if (Platform.OS === 'ios') {\n    return (\n      <BlurView\n        style={[glassStyle, style]}\n        blurType={isDarkMode ? 'dark' : 'light'}\n        blurAmount={blurIntensity}\n        reducedTransparencyFallbackColor={backgroundColor}\n      >\n        {children}\n      </BlurView>\n    );\n  }\n\n  // Fallback for Android\n  return (\n    <View style={[glassStyle, style]}>\n      {children}\n    </View>\n  );\n};\n\n// Floating Particles Effect\nexport const FloatingParticles = ({\n  particleCount = 20,\n  particleColor = FreudColors.serenityGreen[40],\n  particleSize = 4,\n  animationSpeed = 30000,\n  style = {},\n}) => {\n  const particles = useRef(\n    Array.from({ length: particleCount }, (_, i) => ({\n      id: i,\n      animatedValue: new Animated.Value(0),\n      initialX: Math.random() * screenWidth,\n      initialY: Math.random() * screenHeight,\n      opacity: new Animated.Value(Math.random() * 0.8 + 0.2),\n    }))\n  ).current;\n\n  useEffect(() => {\n    const animations = particles.map(particle => {\n      return Animated.loop(\n        Animated.parallel([\n          Animated.timing(particle.animatedValue, {\n            toValue: 1,\n            duration: animationSpeed + Math.random() * 10000,\n            easing: Easing.linear,\n            useNativeDriver: true,\n          }),\n          Animated.sequence([\n            Animated.timing(particle.opacity, {\n              toValue: 0,\n              duration: (animationSpeed + Math.random() * 10000) / 2,\n              useNativeDriver: true,\n            }),\n            Animated.timing(particle.opacity, {\n              toValue: Math.random() * 0.8 + 0.2,\n              duration: (animationSpeed + Math.random() * 10000) / 2,\n              useNativeDriver: true,\n            }),\n          ]),\n        ])\n      );\n    });\n\n    Animated.stagger(1000, animations).start();\n\n    return () => animations.forEach(anim => anim.stop());\n  }, []);\n\n  return (\n    <View style={[styles.particleContainer, style]} pointerEvents=\"none\">\n      {particles.map(particle => {\n        const translateY = particle.animatedValue.interpolate({\n          inputRange: [0, 1],\n          outputRange: [particle.initialY, -100],\n        });\n\n        const translateX = particle.animatedValue.interpolate({\n          inputRange: [0, 0.5, 1],\n          outputRange: [\n            particle.initialX,\n            particle.initialX + (Math.random() - 0.5) * 100,\n            particle.initialX + (Math.random() - 0.5) * 200,\n          ],\n        });\n\n        return (\n          <Animated.View\n            key={particle.id}\n            style={[\n              styles.particle,\n              {\n                width: particleSize,\n                height: particleSize,\n                borderRadius: particleSize / 2,\n                backgroundColor: particleColor,\n                transform: [{ translateX }, { translateY }],\n                opacity: particle.opacity,\n              },\n            ]}\n          />\n        );\n      })}\n    </View>\n  );\n};\n\n// Organic Blob Background\nexport const OrganicBlobBackground = ({\n  blobCount = 3,\n  colors = [FreudColors.serenityGreen[20], FreudColors.kindPurple[20], FreudColors.empathyOrange[20]],\n  animationDuration = 20000,\n  style = {},\n  children,\n}) => {\n  const blobs = useRef(\n    Array.from({ length: blobCount }, (_, i) => ({\n      id: i,\n      scaleAnim: new Animated.Value(0.5 + Math.random() * 0.5),\n      translateXAnim: new Animated.Value(Math.random() * screenWidth),\n      translateYAnim: new Animated.Value(Math.random() * screenHeight),\n      rotateAnim: new Animated.Value(0),\n      color: colors[i % colors.length],\n      size: 200 + Math.random() * 200,\n    }))\n  ).current;\n\n  useEffect(() => {\n    const animations = blobs.map(blob => {\n      return Animated.loop(\n        Animated.parallel([\n          Animated.timing(blob.scaleAnim, {\n            toValue: 1.5,\n            duration: animationDuration + Math.random() * 5000,\n            easing: Easing.inOut(Easing.sin),\n            useNativeDriver: true,\n          }),\n          Animated.timing(blob.rotateAnim, {\n            toValue: 1,\n            duration: animationDuration,\n            easing: Easing.linear,\n            useNativeDriver: true,\n          }),\n          Animated.timing(blob.translateXAnim, {\n            toValue: Math.random() * screenWidth,\n            duration: animationDuration + Math.random() * 10000,\n            easing: Easing.inOut(Easing.quad),\n            useNativeDriver: true,\n          }),\n          Animated.timing(blob.translateYAnim, {\n            toValue: Math.random() * screenHeight,\n            duration: animationDuration + Math.random() * 8000,\n            easing: Easing.inOut(Easing.quad),\n            useNativeDriver: true,\n          }),\n        ])\n      );\n    });\n\n    Animated.stagger(2000, animations).start();\n\n    return () => animations.forEach(anim => anim.stop());\n  }, []);\n\n  const rotate = (rotateAnim) => rotateAnim.interpolate({\n    inputRange: [0, 1],\n    outputRange: ['0deg', '360deg'],\n  });\n\n  return (\n    <View style={[styles.blobContainer, style]}>\n      {blobs.map(blob => (\n        <Animated.View\n          key={blob.id}\n          style={[\n            styles.blob,\n            {\n              width: blob.size,\n              height: blob.size,\n              backgroundColor: blob.color,\n              transform: [\n                { translateX: blob.translateXAnim },\n                { translateY: blob.translateYAnim },\n                { scale: blob.scaleAnim },\n                { rotate: rotate(blob.rotateAnim) },\n              ],\n            },\n          ]}\n        />\n      ))}\n      <View style={styles.blobContent}>\n        {children}\n      </View>\n    </View>\n  );\n};\n\n// Neural Network Background\nexport const NeuralNetworkBackground = ({\n  nodeCount = 15,\n  connectionColor = FreudColors.serenityGreen[30],\n  nodeColor = FreudColors.mindfulBrown[40],\n  animationSpeed = 15000,\n  style = {},\n  children,\n}) => {\n  const nodes = useRef(\n    Array.from({ length: nodeCount }, (_, i) => ({\n      id: i,\n      x: Math.random() * screenWidth,\n      y: Math.random() * screenHeight,\n      pulseAnim: new Animated.Value(0),\n      moveXAnim: new Animated.Value(0),\n      moveYAnim: new Animated.Value(0),\n    }))\n  ).current;\n\n  useEffect(() => {\n    const animations = nodes.map(node => {\n      return Animated.loop(\n        Animated.parallel([\n          Animated.timing(node.pulseAnim, {\n            toValue: 1,\n            duration: 2000 + Math.random() * 3000,\n            easing: Easing.inOut(Easing.quad),\n            useNativeDriver: true,\n          }),\n          Animated.timing(node.moveXAnim, {\n            toValue: (Math.random() - 0.5) * 100,\n            duration: animationSpeed,\n            easing: Easing.inOut(Easing.sin),\n            useNativeDriver: true,\n          }),\n          Animated.timing(node.moveYAnim, {\n            toValue: (Math.random() - 0.5) * 100,\n            duration: animationSpeed + Math.random() * 5000,\n            easing: Easing.inOut(Easing.sin),\n            useNativeDriver: true,\n          }),\n        ])\n      );\n    });\n\n    Animated.stagger(500, animations).start();\n\n    return () => animations.forEach(anim => anim.stop());\n  }, []);\n\n  return (\n    <View style={[styles.neuralContainer, style]}>\n      {/* Connection lines would be drawn here using SVG */}\n      {nodes.map(node => {\n        const pulseScale = node.pulseAnim.interpolate({\n          inputRange: [0, 1],\n          outputRange: [0.5, 1.2],\n        });\n\n        const pulseOpacity = node.pulseAnim.interpolate({\n          inputRange: [0, 0.5, 1],\n          outputRange: [0.3, 1, 0.3],\n        });\n\n        return (\n          <Animated.View\n            key={node.id}\n            style={[\n              styles.neuralNode,\n              {\n                left: node.x,\n                top: node.y,\n                backgroundColor: nodeColor,\n                transform: [\n                  { translateX: node.moveXAnim },\n                  { translateY: node.moveYAnim },\n                  { scale: pulseScale },\n                ],\n                opacity: pulseOpacity,\n              },\n            ]}\n          />\n        );\n      })}\n      <View style={styles.neuralContent}>\n        {children}\n      </View>\n    </View>\n  );\n};\n\n// Ripple Effect Background\nexport const RippleEffectBackground = ({\n  rippleColor = FreudColors.serenityGreen[30],\n  rippleCount = 5,\n  duration = 3000,\n  interval = 600,\n  style = {},\n  children,\n}) => {\n  const [ripples, setRipples] = useState([]);\n  const rippleCounter = useRef(0);\n\n  useEffect(() => {\n    const createRipple = () => {\n      const id = rippleCounter.current++;\n      const x = Math.random() * screenWidth;\n      const y = Math.random() * screenHeight;\n      \n      setRipples(prev => [...prev, { id, x, y, scale: new Animated.Value(0), opacity: new Animated.Value(1) }]);\n      \n      setTimeout(() => {\n        setRipples(prev => prev.filter(ripple => ripple.id !== id));\n      }, duration);\n    };\n\n    const intervalId = setInterval(createRipple, interval);\n    return () => clearInterval(intervalId);\n  }, []);\n\n  useEffect(() => {\n    ripples.forEach(ripple => {\n      Animated.parallel([\n        Animated.timing(ripple.scale, {\n          toValue: 1,\n          duration,\n          easing: Easing.out(Easing.quad),\n          useNativeDriver: true,\n        }),\n        Animated.timing(ripple.opacity, {\n          toValue: 0,\n          duration,\n          easing: Easing.out(Easing.quad),\n          useNativeDriver: true,\n        }),\n      ]).start();\n    });\n  }, [ripples]);\n\n  return (\n    <View style={[styles.rippleContainer, style]}>\n      {ripples.map(ripple => (\n        <Animated.View\n          key={ripple.id}\n          style={[\n            styles.ripple,\n            {\n              left: ripple.x - 50,\n              top: ripple.y - 50,\n              backgroundColor: rippleColor,\n              transform: [{ scale: ripple.scale }],\n              opacity: ripple.opacity,\n            },\n          ]}\n        />\n      ))}\n      <View style={styles.rippleContent}>\n        {children}\n      </View>\n    </View>\n  );\n};\n\nconst styles = StyleSheet.create({\n  gradientContainer: {\n    flex: 1,\n    position: 'relative',\n  },\n  gradient: {\n    position: 'absolute',\n    top: 0,\n    left: 0,\n    right: 0,\n    bottom: 0,\n  },\n\n  particleContainer: {\n    position: 'absolute',\n    top: 0,\n    left: 0,\n    right: 0,\n    bottom: 0,\n  },\n  particle: {\n    position: 'absolute',\n  },\n\n  blobContainer: {\n    flex: 1,\n    position: 'relative',\n    overflow: 'hidden',\n  },\n  blob: {\n    position: 'absolute',\n    borderRadius: 9999,\n    opacity: 0.6,\n  },\n  blobContent: {\n    flex: 1,\n    zIndex: 10,\n  },\n\n  neuralContainer: {\n    flex: 1,\n    position: 'relative',\n    overflow: 'hidden',\n  },\n  neuralNode: {\n    position: 'absolute',\n    width: 8,\n    height: 8,\n    borderRadius: 4,\n  },\n  neuralContent: {\n    flex: 1,\n    zIndex: 10,\n  },\n\n  rippleContainer: {\n    flex: 1,\n    position: 'relative',\n    overflow: 'hidden',\n  },\n  ripple: {\n    position: 'absolute',\n    width: 100,\n    height: 100,\n    borderRadius: 50,\n    opacity: 0.5,\n  },\n  rippleContent: {\n    flex: 1,\n    zIndex: 10,\n  },\n});\n\nexport default {\n  TherapeuticGradient,\n  GlassmorphismContainer,\n  FloatingParticles,\n  OrganicBlobBackground,\n  NeuralNetworkBackground,\n  RippleEffectBackground,\n};